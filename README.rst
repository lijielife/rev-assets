===========================
RevAssets
===========================

.. image:: https://travis-ci.org/jpscaletti/rev-assets.svg?branch=master
   :target: https://travis-ci.org/jpscaletti/rev-assets
   :alt: Build Status

You care about the performance of your site, so you've configured the web server to cache all your assets for a long time. The most used way to bypass that cache when deploying a new version, is to add a hash of the assets to their names.
::
    'scripts/home.js' --> 'scripts/home.1a23b.js'
    'styles/home.css' --> 'styles/home.aef45.css'

The problem is, now your Python web app can't find the file unless you manually –and painstakingly— update all the URLs in the templates.

.. code:: html+jinja

    <script src="{{ url_for('static', filename='scripts/home.js') }}></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/home.css') }}</script>

Whit this library, there is no need for that. Just change your templates to:

.. code:: html+jinja

    <script src="{{ 'scripts/home.js' | asset_url }}></script>
    <link rel="stylesheet" href="{{ 'styles/home.css' | asset_url }}</script>

and use this code:

.. code:: python

    # app.py
    from flask import Flask, render_template
    from rev_assets import RevAssets

    app = flask.Flask(__name__)

    rev = RevAssets(reload=app.debug)
    app.jinja_env.filters['asset_url'] = rev.asset_url

    @app.route('/')
    def index():
        return render_template('index.html')

and it will work for every version of the assets that you build.

This works by reading the ``manifest.json`` generated by the revision tool (so don't forget to configure your task runner to make one).

You can continue to use the old method to link un-versioned assets, like ``favicon.ico`` and others like it.

Note that *this is not a Flask extension*, but a Python library. You can use it with any other framework. You can also have many instances of ``RevAssets`` linked to differents manifests.


Parameters
======================

.. code:: python

    rev = RevAssets([base_url], [reload], [manifest], [quiet])

:base_url: (``/static``)
    Prefix for the found assets. Can be a local path or a different domain, like a CDN.
:reload: (``False``) 
    Reload the manifest file eash time an asset is requested
:manifest: (``manifest.json``)
    Relative or absolute path to a JSON file that maps the source files to the hashed versions. Eg.: ``scripts/home.js`` to ``scripts/home.1a23b.js``.
:quiet: (``True``)
    If ``False``, a missing asset will raise an exception. If ``True``, an empty string will be returned instead.


An example config file for `Gulp.js <http://gulpjs.com/>`_
============================================================

It doesn't matter what task runner do you use, as long as it's configured to generate a ``manifest.json`` file. However, it's not always easy to do it. So this is a working ``gulpfile.js`` you can use it to process your assets or take as a reference.

With this config:

- All the ``.scss`` (sass) files in ``static/styles`` are compiled to CSS, autoprefixed, minified, sourcemapped, hashed an copied into ``static/build/styles``.
- All the javascript files in ``static/scripts`` are compiled from ES6 Javascript to ES5 (the one all browsers understand), minified, sourcemapped, hashed an copied into ``static/build/scripts``. You might want to add here a ``browserify`` step.
- The images in ``static/images`` are optimized, hashed and copied into ``static/build/images``.
- The font files in ``static/fonts`` are hashed and copied into ``static/build/fonts``.
- Then, every reference to this names in your final CSS files, are updated so the relative ``url(...)`` continue to work.
- And, of course, a global ``manifest.json`` is generated for all of them.


.. code:: JavaScript
    
    // gulpfile.js
    const gulp = require('gulp');
    const extend = require('extend');
    const parseArgs = require('minimist');
    const through = require("through2");

    const autoprefixer = require('gulp-autoprefixer');
    const babel = require('gulp-babel');
    const del = require('del');
    const cssmin = require('gulp-cssmin');
    const imagemin = require('gulp-imagemin');
    const rev = require('gulp-rev');
    const revreplace = require("gulp-rev-replace");
    const runseq = require('run-sequence');
    const sass = require('gulp-sass');
    const sourcemaps = require('gulp-sourcemaps');
    const uglify = require('gulp-uglify');

    const SOURCE_PATH = 'assets';
    const BUILD_PATH = 'assets/build';
    const MANIFEST_FILE = BUILD_PATH + '/rev-manifest.json';


    const config = extend({
       env: process.env.NODE_ENV || 'dev'
    }, parseArgs(process.argv.slice(2)));

    // Does nothing but can be .pipe()'d
    const noop = through.obj();


    gulp.task('sass', () => {
      del.sync([BUILD_PATH + '/styles/**']);
      return gulp
        .src(SOURCE_PATH + '/styles/**/*.scss', {base: SOURCE_PATH})
        .pipe(sourcemaps.init())
        .pipe(
          sass(config.env == 'prod' ? {outputStyle: 'compressed'} : {})
          .on('error', sass.logError)
        )
        .pipe(
          autoprefixer({
            browsers: ['last 2 versions', 'ie >= 9', 'and_chr >= 2.3'],
            cascade: false,
          })
        )
        .pipe(config.env == 'prod' ? cssmin() : noop)
        .pipe(rev())
        .pipe(sourcemaps.write('.'))
        .pipe(gulp.dest(BUILD_PATH))
        .pipe(rev.manifest(
          MANIFEST_FILE,
          {merge: true, base:BUILD_PATH}
        ))
        .pipe(gulp.dest(BUILD_PATH))
        ;
    });

    gulp.task('js', () => {
      del.sync([BUILD_PATH + '/scripts/**']);
      return gulp
        .src([
          SOURCE_PATH + '/scripts/**/*.js',
          '!**/_*.js'
        ], {base: SOURCE_PATH})
        .pipe(sourcemaps.init())
        .pipe(
          babel({
            presets: ['es2015'],
          })
        )
        .pipe(config.env == 'prod' ? uglify() : noop)
        .pipe(rev())
        .pipe(sourcemaps.write('.'))
        .pipe(gulp.dest(BUILD_PATH))
        .pipe(rev.manifest(
          MANIFEST_FILE,
          {merge: true, base:BUILD_PATH}
        ))
        .pipe(gulp.dest(BUILD_PATH))
        ;
    });

    gulp.task('images', () => {
      del.sync([BUILD_PATH + '/images/**']);
      return gulp
        .src(SOURCE_PATH + '/images/**', {base: SOURCE_PATH})
        .pipe(imagemin([
          imagemin.gifsicle({interlaced: true}),
          imagemin.jpegtran({progressive: true}),
          imagemin.optipng({optimizationLevel: 5}),
          imagemin.svgo({plugins: [{removeViewBox: true}]})
        ]))
        .pipe(rev())
        .pipe(gulp.dest(BUILD_PATH))
        .pipe(rev.manifest(
          MANIFEST_FILE,
          {merge: true, base:BUILD_PATH}
        ))
        .pipe(gulp.dest(BUILD_PATH))
        ;
    });

    gulp.task('fonts', () => {
      del.sync([BUILD_PATH + '/fonts/**']);
      return gulp
        .src(SOURCE_PATH + '/fonts/**', {base: SOURCE_PATH})
        .pipe(rev())
        .pipe(gulp.dest(BUILD_PATH))
        .pipe(rev.manifest(
          MANIFEST_FILE,
          {merge: true, base:BUILD_PATH}
        ))
        .pipe(gulp.dest(BUILD_PATH))
        ;
    });

    gulp.task('revreplace', () => {
      return gulp.src(BUILD_PATH + '/**/*.css')
        .pipe(revreplace({
          manifest: gulp.src(MANIFEST_FILE)
        }))
        .pipe(gulp.dest(BUILD_PATH));
    });

    gulp.task('sass:watch', () => {
      gulp.watch(
        SOURCE_PATH + '/styles/*.scss',
        () => runseq('sass', 'revreplace')
      );
    });

    gulp.task('js:watch', () => {
      gulp.watch(
        SOURCE_PATH + '/scripts/*.js',
        () => runseq('js', 'revreplace')
      );
    });

    gulp.task('images:watch', () => {
      gulp.watch(
        [SOURCE_PATH + '/images/**'],
        () => runseq('images', 'revreplace')
      );
    });

    gulp.task('fonts:watch', () => {
      gulp.watch(
        [SOURCE_PATH + '/fonts/**'],
        () => runseq('fonts', 'revreplace')
      );
    });

    gulp.task('clear', () => {
      del.sync([MANIFEST_FILE]);
    });

    // Development build
    gulp.task('dev-build', () => runseq(
      'clear',
      ['sass', 'js'],
      ['images', 'fonts'],
      'revreplace'
    ));

    // Production build
    gulp.task('prod-build', () => {
      process.env.NODE_ENV = config.env = 'prod';
      runseq('dev-build');
    });

    gulp.task('watch', ['sass:watch', 'js:watch', 'images:watch', 'fonts:watch']);

    gulp.task('default', ['dev-build']);
    gulp.task('build', ['prod-build']);


and the ``package.json`` file with the dependencies.

.. code:: json

    {
      "devDependencies": {
        "babel-preset-es2015": "^6.24.1",
        "del": "^2.2.2",
        "gulp": "^3.9.1",
        "gulp-autoprefixer": "^3.1.1",
        "gulp-babel": "^6.1.2",
        "gulp-cssmin": "^0.1.7",
        "gulp-imagemin": "^3.2.0",
        "gulp-rev": "^7.1.2",
        "gulp-rev-replace": "^0.4.3",
        "gulp-sass": "^3.1.0",
        "gulp-sourcemaps": "^2.6.0",
        "gulp-uglify": "^2.1.2",
        "run-sequence": "^1.2.2"
      }
    }


Run the tests
======================

We use some external dependencies, listed in ``requirements_tests.txt``::

    $  pip install -r requirements-tests.txt
    $  python setup.py develop

To run the tests in your current Python version do::

    $  make test

To run them in every supported Python version do::

    $  tox

Our test suite `runs continuously on Travis CI <https://travis-ci.org/jpscaletti/rev-assets>`_ with every update.


Contributing
======================

#. Check for `open issues <https://github.com/jpscaletti/rev-assets/issues>`_ or open
   a fresh issue to start a discussion around a feature idea or a bug.
#. Fork the `RevAssets repository on Github <https://github.com/jpscaletti/rev-assets>`_
   to start making your changes.
#. Write a test which shows that the bug was fixed or that the feature works
   as expected.
#. Send a pull request and bug the maintainer until it gets merged and published.
   :) Make sure to add yourself to ``AUTHORS``.

______

:copyright: `Juan-Pablo Scaletti <http://jpscaletti.com/>`_.
:license: BSD-3-Clause, see LICENSE.
